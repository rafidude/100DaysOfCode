stop("Covariance matrix not positive definite")
# remark: could use generalized inverse if cov.mat is positive semidefinite
#
# compute efficient portfolio
#
ones <- rep(1, length(er))
top <- cbind(2*cov.mat, er, ones)
bot <- cbind(rbind(er, ones), matrix(0,2,2))
A <- rbind(top, bot)
b.target <- as.matrix(c(rep(0, length(er)), target.return, 1))
x <- solve(A, b.target)
w <- x[1:length(er)]
names(w) <- asset.names
#
# compute portfolio expected returns and variance
#
er.port <- crossprod(er,w)
sd.port <- sqrt(w %*% cov.mat %*% w)
ans <- list("call" = call,
"er" = as.vector(er.port),
"sd" = as.vector(sd.port),
"weights" = w)
class(ans) <- "portfolio"
ans
}
globalMin.portfolio <-
function(er, cov.mat)
{
# Compute global minimum variance portfolio
#
# inputs:
# er        N x 1 vector of expected returns
# cov.mat   N x N return covariance matrix
#
# output is portfolio object with the following elements
# call      original function call
# er        portfolio expected return
# sd        portfolio standard deviation
# weights   N x 1 vector of portfolio weights
call <- match.call()
#
# check for valid inputs
#
asset.names <- names(er)
er <- as.vector(er)         # assign names if none exist
cov.mat <- as.matrix(cov.mat)
if(length(er) != nrow(cov.mat))
stop("invalid inputs")
if(any(diag(chol(cov.mat)) <= 0))
stop("Covariance matrix not positive definite")
# remark: could use generalized inverse if cov.mat is positive semi-definite
#
# compute global minimum portfolio
#
cov.mat.inv <- solve(cov.mat)
one.vec <- rep(1,length(er))
#  w.gmin <- cov.mat.inv %*% one.vec/as.vector(one.vec %*% cov.mat.inv %*% one.vec)
w.gmin <- rowSums(cov.mat.inv) / sum(cov.mat.inv)
w.gmin <- as.vector(w.gmin)
names(w.gmin) <- asset.names
er.gmin <- crossprod(w.gmin,er)
sd.gmin <- sqrt(t(w.gmin) %*% cov.mat %*% w.gmin)
gmin.port <- list("call" = call,
"er" = as.vector(er.gmin),
"sd" = as.vector(sd.gmin),
"weights" = w.gmin)
class(gmin.port) <- "portfolio"
gmin.port
}
tangency.portfolio <-
function(er,cov.mat,risk.free)
{
# compute tangency portfolio
#
# inputs:
# er           N x 1 vector of expected returns
# cov.mat      N x N return covariance matrix
# risk.free    scalar, risk-free rate
#
# output is portfolio object with the following elements
# call        captures function call
# er          portfolio expected return
# sd          portfolio standard deviation
# weights    N x 1 vector of portfolio weights
call <- match.call()
#
# check for valid inputs
#
asset.names <- names(er)
if(risk.free < 0)
stop("Risk-free rate must be positive")
er <- as.vector(er)
cov.mat <- as.matrix(cov.mat)
if(length(er) != nrow(cov.mat))
stop("invalid inputs")
if(any(diag(chol(cov.mat)) <= 0))
stop("Covariance matrix not positive definite")
# remark: could use generalized inverse if cov.mat is positive semi-definite
#
# compute global minimum variance portfolio
#
gmin.port <- globalMin.portfolio(er,cov.mat)
if(gmin.port$er < risk.free)
stop("Risk-free rate greater than avg return on global minimum variance portfolio")
#
# compute tangency portfolio
#
cov.mat.inv <- solve(cov.mat)
w.t <- cov.mat.inv %*% (er - risk.free) # tangency portfolio
w.t <- as.vector(w.t/sum(w.t))  # normalize weights
names(w.t) <- asset.names
er.t <- crossprod(w.t,er)
sd.t <- sqrt(t(w.t) %*% cov.mat %*% w.t)
tan.port <- list("call" = call,
"er" = as.vector(er.t),
"sd" = as.vector(sd.t),
"weights" = w.t)
class(tan.port) <- "portfolio"
tan.port
}
efficient.frontier <-
function(er, cov.mat, nport=20, alpha.min=-0.5, alpha.max=1.5)
{
# Compute efficient frontier with no short-sales constraints
#
# inputs:
# er        N x 1 vector of expected returns
# cov.mat   N x N return covariance matrix
# nport     scalar, number of efficient portfolios to compute
#
# output is a Markowitz object with the following elements
# call      captures function call
# er        nport x 1 vector of expected returns on efficient porfolios
# sd        nport x 1 vector of std deviations on efficient portfolios
# weights   nport x N matrix of weights on efficient portfolios
call <- match.call()
#
# check for valid inputs
#
asset.names <- names(er)
er <- as.vector(er)
cov.mat <- as.matrix(cov.mat)
if(length(er) != nrow(cov.mat))
stop("invalid inputs")
if(any(diag(chol(cov.mat)) <= 0))
stop("Covariance matrix not positive definite")
#
# create portfolio names
#
port.names <- rep("port",nport)
ns <- seq(1,nport)
port.names <- paste(port.names,ns)
#
# compute global minimum variance portfolio
#
cov.mat.inv <- solve(cov.mat)
one.vec <- rep(1,length(er))
port.gmin <- globalMin.portfolio(er,cov.mat)
w.gmin <- port.gmin$weights
#
# compute efficient frontier as convex combinations of two efficient portfolios
# 1st efficient port: global min var portfolio
# 2nd efficient port: min var port with ER = max of ER for all assets
#
er.max <- max(er)
port.max <- efficient.portfolio(er,cov.mat,er.max)
w.max <- port.max$weights
a <- seq(from=alpha.min,to=alpha.max,length=nport)      # convex combinations
we.mat <- a %o% w.gmin + (1-a) %o% w.max  # rows are efficient portfolios
er.e <- we.mat %*% er             # expected returns of efficient portfolios
er.e <- as.vector(er.e)
names(er.e) <- port.names
cov.e <- we.mat %*% cov.mat %*% t(we.mat) # cov mat of efficient portfolios
sd.e <- sqrt(diag(cov.e))         # std devs of efficient portfolios
sd.e <- as.vector(sd.e)
names(sd.e) <- port.names
dimnames(we.mat) <- list(port.names,asset.names)
#
# summarize results
#
ans <- list("call" = call,
"er" = er.e,
"sd" = sd.e,
"weights" = we.mat)
class(ans) <- "Markowitz"
ans
}
#
# print method for portfolio object
print.portfolio <- function(x, ...)
{
cat("Call:\n")
print(x$call, ...)
cat("\nPortfolio expected return:    ", format(x$er, ...), "\n")
cat("Portfolio standard deviation: ", format(x$sd, ...), "\n")
cat("Portfolio weights:\n")
print(round(x$weights,4), ...)
invisible(x)
}
#
# summary method for portfolio object
summary.portfolio <- function(object, risk.free=NULL, ...)
# risk.free     risk-free rate. If not null then
#       compute and print Sharpe ratio
#
{
cat("Call:\n")
print(object$call)
cat("\nPortfolio expected return:    ", format(object$er, ...), "\n")
cat(  "Portfolio standard deviation: ", format(object$sd, ...), "\n")
if(!is.null(risk.free)) {
SharpeRatio <- (object$er - risk.free)/object$sd
cat("Portfolio Sharpe Ratio:       ", format(SharpeRatio), "\n")
}
cat("Portfolio weights:\n")
print(round(object$weights,4), ...)
invisible(object)
}
# hard-coded 4 digits; prefer to let user control, via ... or other argument
#
# plot method for portfolio object
plot.portfolio <- function(object, ...)
{
asset.names <- names(object$weights)
barplot(object$weights, names=asset.names,
xlab="Assets", ylab="Weight", main="Portfolio Weights", ...)
invisible()
}
#
# print method for Markowitz object
print.Markowitz <- function(x, ...)
{
cat("Call:\n")
print(x$call)
xx <- rbind(x$er,x$sd)
dimnames(xx)[[1]] <- c("ER","SD")
cat("\nFrontier portfolios' expected returns and standard deviations\n")
print(round(xx,4), ...)
invisible(x)
}
# hard-coded 4, should let user control
#
# summary method for Markowitz object
summary.Markowitz <- function(object, risk.free=NULL)
{
call <- object$call
asset.names <- colnames(object$weights)
port.names <- rownames(object$weights)
if(!is.null(risk.free)) {
# compute efficient portfolios with a risk-free asset
nport <- length(object$er)
sd.max <- object$sd[1]
sd.e <- seq(from=0,to=sd.max,length=nport)
names(sd.e) <- port.names
#
# get original er and cov.mat data from call
er <- eval(object$call$er)
cov.mat <- eval(object$call$cov.mat)
#
# compute tangency portfolio
tan.port <- tangency.portfolio(er,cov.mat,risk.free)
x.t <- sd.e/tan.port$sd   # weights in tangency port
rf <- 1 - x.t     # weights in t-bills
er.e <- risk.free + x.t*(tan.port$er - risk.free)
names(er.e) <- port.names
we.mat <- x.t %o% tan.port$weights  # rows are efficient portfolios
dimnames(we.mat) <- list(port.names, asset.names)
we.mat <- cbind(rf,we.mat)
}
else {
er.e <- object$er
sd.e <- object$sd
we.mat <- object$weights
}
ans <- list("call" = call,
"er"=er.e,
"sd"=sd.e,
"weights"=we.mat)
class(ans) <- "summary.Markowitz"
ans
}
print.summary.Markowitz <- function(x, ...)
{
xx <- rbind(x$er,x$sd)
port.names <- names(x$er)
asset.names <- colnames(x$weights)
dimnames(xx)[[1]] <- c("ER","SD")
cat("Frontier portfolios' expected returns and standard deviations\n")
print(round(xx,4), ...)
cat("\nPortfolio weights:\n")
print(round(x$weights,4), ...)
invisible(x)
}
# hard-coded 4, should let user control
#
# plot efficient frontier
#
# things to add: plot original assets with names
# tangency portfolio
# global min portfolio
# risk free asset and line connecting rf to tangency portfolio
#
plot.Markowitz <- function(object, plot.assets=FALSE, ...)
# plot.assets   logical. If true then plot asset sd and er
{
if (!plot.assets) {
y.lim=c(0,max(object$er))
x.lim=c(0,max(object$sd))
plot(object$sd,object$er,type="b",xlim=x.lim, ylim=y.lim,
xlab="Portfolio SD", ylab="Portfolio ER",
main="Efficient Frontier", ...)
}
else {
call = object$call
mu.vals = eval(call$er)
sd.vals = sqrt( diag( eval(call$cov.mat) ) )
y.lim = range(c(0,mu.vals,object$er))
x.lim = range(c(0,sd.vals,object$sd))
plot(object$sd,object$er,type="b", xlim=x.lim, ylim=y.lim,
xlab="Portfolio SD", ylab="Portfolio ER",
main="Efficient Frontier", ...)
text(sd.vals, mu.vals, labels=names(mu.vals))
}
invisible()
}
global_min_var_portfolio = globalMin.portfolio(mu_hat_annual,cov_mat_annual)
global_min_var_portfolio
global_min_var_portfolio
# Summary of global_min_var_portfolio that takes into account the annual risk-free rate of 3% per year
summary(global_min_var_portfolio, risk.free=0.03)
plot(global_min_var_portfolio)
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
# Plot the position of the global minimum variance portfolio
text(x=global_min_var_portfolio$sd, y=global_min_var_portfolio$er, labels="Global min", pos=2)
initial = 100000
interest = 8%
interest = 0.08
interest = 0.08 # 8%
periods = 10
periods = 10 # years
final = (1 + interest*periods)*initial
final
simple = (1 + interest*periods)*initial
simple
compound = ((1 + interest)^periods)*initial
compound
100/(1.04)^3
AnnuityK = function(amount, interest, period){
return amount/(1 + interest)^period
}
AnnuityK <- function(amount, interest, period) {
return amount/(1 + interest)^period
}
AnnuityK <- function(amount, interest, period) amount/(1 + interest)^period
AnnuityK(100, 0.04, 3)
sum <- 0
for (n in 1:10){
sum <- sum + AnnuityK(100, 0.04, n)
print(sum)
}
Annuity <- function(amount, interest, period) (1/interest)*(amount - amount/(1 + interest)^period)
Annuity(100, 0.04, 10)
perpetualPV = amount/interest
amount = 100; interest = 0.04
perpetualPV = amount/interest
perpetualPV
Annuity <- function(amount, interest, period) (amount/interest)*(1 - 1/(1 + interest)^period)
Annuity(100, 0.04, 10)
amount = 1000; interest = 0.03
perpetualPV = amount/interest
amount/interest
Annuity(1000, 0.03, 100)
Annuity(1000, 0.03, 1000)
Annuity(1000, 0.03, 15)
Annuity(1000, 0.03, 1000) - Annuity(1000, 0.03, 15)
faceValue <- 1000
rate <- 0.05
coupon <- 100
periods <- 20
bondPresentValue <- faceValue/(1 + rate)^periods + coupon/rate*(1 - (1/((1 + rate)^periods)))
bondPresentValue
bondPresentValue <- function(faceValue, rate, coupon, periods) faceValue/(1 + rate)^periods + coupon/rate*(1 - (1/((1 + rate)^periods)))
bondPresentValue(faceValue, rate, coupon, periods)
install.packages(c("cluster", "manipulate"))
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages("~/Downloads/PerformanceAnalytics_1.4.3541.tgz", repos = NULL)
library("PerformanceAnalytics", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages("xts")
library("PerformanceAnalytics", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages("PerformanceAnalytics")
library("PerformanceAnalytics", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("PerformanceAnalytics")
library("zoo")
# Load the data
load(url("http://s3.amazonaws.com/assets.datacamp.com/course/compfin/lab8.RData"))
# Explore the data set
head(returns_df)
mu_hat_annual = apply(returns_df,2,mean)*12
sigma2_annual = apply(returns_df,2,var)*12
sigma_annual = sqrt(sigma2_annual)
cov_mat_annual = cov(returns_df)*12
cov_hat_annual = cov(returns_df)[1,2]*12
rho_hat_annual = cor(returns_df)[1,2]
# The annual estimates of the CER model parameters for Boeing and Microsoft
mu_boeing = mu_hat_annual["rboeing"]
mu_msft = mu_hat_annual["rmsft"]
sigma2_boeing =  sigma2_annual["rboeing"]
sigma2_msft = sigma2_annual["rmsft"]
sigma_boeing = sigma_annual["rboeing"]
sigma_msft = sigma_annual["rmsft"]
sigma_boeing_msft = cov_hat_annual
rho_boeing_msft = rho_hat_annual
head(returns_df)
mu_hat_annual
sigma2_annual
sigma_annual
cov_mat_annual
cov_hat_annual
rho_hat_annual
mu_boeing
mu_msft
sigma2_boeing
sigma2_msft
sigma_boeing
sigma_msft
sigma_boeing_msft
rho_boeing_msft
boeing_weights = seq(from=-1, to=2, by=0.1)
boeing_weights
msft_weights = 1 - boeing_weights
msft_weights
mu_portfolio =  mu_boeing * boeing_weights + mu_msft * msft_weights
mu_portfolio
sigma2_portfolio =  boeing_weights^2 * sigma2_boeing + msft_weights^2 * sigma2_msft + 2*boeing_weights*msft_weights*sigma_boeing_msft
sigma2_portfolio
sigma_portfolio = sqrt(sigma2_portfolio)
sigma_portfolio
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="Microsoft", pos=4)
t_bill_rate = 0.03
# Ratio Boeing stocks
boeing_weights = seq(from=-1, to=2, by=0.1)
boeing_weights
mu_portfolio_boeing_bill = t_bill_rate + boeing_weights*(mu_boeing - t_bill_rate)
mu_portfolio_boeing_bill
sigma_portfolio_boeing_bill =  boeing_weights * sigma_boeing
sigma_portfolio_boeing_bill
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
points(sigma_portfolio_boeing_bill, mu_portfolio_boeing_bill, type="b", col="blue")
sharp_ratio_boeing = (mu_boeing - t_bill_rate)/sigma_boeing
sharp_ratio_boeing
global_min_var_portfolio = globalMin.portfolio(mu_hat_annual,cov_mat_annual)
global_min_var_portfolio
summary(global_min_var_portfolio, risk.free = 0.03)
plot(global_min_var_portfolio)
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
# Plot the position of the global minimum variance portfolio
text(x=global_min_var_portfolio$sd, y=global_min_var_portfolio$er, labels="Global min", pos=2)
tangency_portfolio = tangency.portfolio(mu_hat_annual, cov_mat_annual,risk.free=0.03)
tangency_portfolio
# Summary of tangency_portfolio with annual risk free rate of 3%
summary(tangency_portfolio ,risk.free=0.03)
# Portfolio weights Boeing and Microsoft
plot(tangency_portfolio)
t_bill_rate = 0.03
# Set of tangency portfolio weights
tangency_weights = seq(from=0, to=2, by=0.1)
# Portfolio parameters
mu_portfolio_tangency_bill = t_bill_rate + tangency_weights*(tangency_portfolio$er-t_bill_rate)
sigma_portfolio_tangency_bill = tangency_weights*tangency_portfolio$sd
# Plot previous exercises
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
# Plot portfolio combinations of tangency portfolio and T-bills
text(x=tangency_portfolio$sd, y=tangency_portfolio$er, labels="Tangency", pos=2)
points(sigma_portfolio_tangency_bill, mu_portfolio_tangency_bill, type="b", col="blue", pch=16)
tangency_weight = 0.3
t_bill_weight = 1 - tangency_weight
# Define the portfolio parameters
mu_portfolio_efficient = t_bill_rate + tangency_weight*(tangency_portfolio$er - t_bill_rate)
sd_portfolio_efficient = tangency_weight*tangency_portfolio$sd
# Plot previous exercises
plot(sigma_portfolio, mu_portfolio, type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
text(x=tangency_portfolio$sd, y=tangency_portfolio$er, labels="Tangency", pos=2)
points(sigma_portfolio_tangency_bill, mu_portfolio_tangency_bill, type="b", col="blue", pch=16)
# Plot Efficient Portfolio with 30% Tangency
points(sd_portfolio_efficient, mu_portfolio_efficient, type="p", col="orange", pch=16, cex=2)
text(x=sd_portfolio_efficient, y=mu_portfolio_efficient, labels="Efficient Portfolio with 30% Tangency", pos=4, cex=0.75)
tangency_weight  = sigma_boeing/tangency_portfolio$sd
tangency_weight
mu_portfolio_efficient = t_bill_rate + tangency_weight*(tangency_portfolio$er - t_bill_rate)
mu_portfolio_efficient
sd_portfolio_efficient = tangency_weight*tangency_portfolio$sd
sd_portfolio_efficient
plot(sigma_portfolio, mu_portfolio,bg="NA", type="b", pch=16, ylim=c(0, max(mu_portfolio)), xlim=c(0, max(sigma_portfolio)), xlab=expression(sigma[p]), ylab=expression(mu[p]),col=c(rep("green", 18), rep("red", 13)))
text(x=sigma_boeing, y=mu_boeing, labels="Boeing", pos=4)
text(x=sigma_msft, y=mu_msft, labels="MSFT", pos=4)
text(x=tangency_portfolio$sd, y=tangency_portfolio$er, labels="Tangency", pos=2)
points(sigma_portfolio_tangency_bill, mu_portfolio_tangency_bill, type="b", col="blue", pch=16)
# Plot Efficient Portfolio with the same risk as Boeing
points(sd_portfolio_efficient, mu_portfolio_efficient, type="p", col="orange", pch=16, cex=2)
text(x=sd_portfolio_efficient, y=mu_portfolio_efficient, labels="Efficient Portfolio with same risk as Boeing", pos=2, cex=0.75)
